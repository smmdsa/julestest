<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Roguelike Raycaster</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            border: 2px solid #888;
            box-shadow: 0 0 20px #ff0000;
            position: relative;
            background-color: #000;
        }
        canvas {
            display: block;
            background-color: #333;
            cursor: none;
        }
        #crosshair {
            position: absolute;
            color: white;
            font-size: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #info-panel {
            margin-top: 15px;
            display: flex;
            justify-content: space-around;
            width: 640px;
            background-color: #111;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
        }
        #info-panel div {
            text-align: center;
        }
        #loading-screen {
            position: absolute;
            top: -100%; /* Start hidden above */
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 100;
            transition: top 0.7s ease-in-out;
        }
    </style>
</head>
<body>
    <h1>HTML5 Roguelike Raycaster</h1>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crosshair">+</div>
        <div id="loading-screen">Generating Level...</div>
    </div>
    <div id="info-panel">
        <div id="level-ui">Level: 1</div>
        <div id="health-ui">Health: 100</div>
        <div id="shield-ui">Shield: 0</div>
        <div id="ammo-ui">Ammo: 15 / 50</div>
        <div id="score-ui">Score: 0</div>
    </div>
     <div id="controls" style="font-size: 0.8em; margin-top: 10px; text-align: center;">
        <strong>Controls:</strong> W/A/S/D: Move | Mouse: Look | Click: Shoot | R: Reload
    </div>

    <script>
        // --- Setup and Configuration ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');

        const screenWidth = 640;
        const screenHeight = 400;
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        // --- Game Constants ---
        const MAX_HEALTH = 100;
        const MAX_SHIELD = 100;
        const CLIP_SIZE = 15;
        const MAX_AMMO_CARRY = 50;

        const ENEMY_TYPES = {
            'grunt':    { health: 100, damage: 10, color: '#00ff00', scale: 1.0, aspectRatio: 0.8, score: 100, attackCooldown: 120 },
            'sergeant': { health: 150, damage: 20, color: '#00bfff', scale: 1.1, aspectRatio: 0.8, score: 200, attackCooldown: 100 },
            'commander':{ health: 200, damage: 30, color: '#ff4500', scale: 1.2, aspectRatio: 0.8, score: 300, attackCooldown: 80 },
            'boss':     { health: 500, damage: 50, color: '#ff00ff', scale: 1.5, aspectRatio: 0.8, score: 1000, attackCooldown: 60 }
        };

        // --- Game State ---
        let gameState = {
            currentLevel: 1,
            player: {
                x: 0, y: 0,
                dirX: -1, dirY: 0,
                planeX: 0, planeY: 0.66,
                moveSpeed: 0.05, rotSpeed: 0.03,
                health: MAX_HEALTH,
                shield: 0,
                ammo: MAX_AMMO_CARRY,
                clipAmmo: CLIP_SIZE,
                score: 0,
                isHit: 0,
                hasKey: false
            },
            map: [],
            mapWidth: 25, // Must be odd
            mapHeight: 25, // Must be odd
            sprites: [],
            zBuffer: new Array(screenWidth)
        };

        // --- Input Handling ---
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        canvas.addEventListener('click', () => { canvas.requestPointerLock(); shoot(); });
        document.addEventListener('pointerlockchange', () => {
             if (document.pointerLockElement === canvas) document.addEventListener("mousemove", updateRotation, false);
             else document.removeEventListener("mousemove", updateRotation, false);
        }, false);

        function updateRotation(e) {
            const rotAmount = e.movementX * 0.002;
            const p = gameState.player;
            const oldDirX = p.dirX;
            p.dirX = p.dirX * Math.cos(-rotAmount) - p.dirY * Math.sin(-rotAmount);
            p.dirY = oldDirX * Math.sin(-rotAmount) + p.dirY * Math.cos(-rotAmount);
            const oldPlaneX = p.planeX;
            p.planeX = p.planeX * Math.cos(-rotAmount) - p.planeY * Math.sin(-rotAmount);
            p.planeY = oldPlaneX * Math.sin(-rotAmount) + p.planeY * Math.cos(-rotAmount);
        }
        
        // --- Map Generation (Randomized DFS Maze) ---
        function generateMap() {
            const w = gameState.mapWidth;
            const h = gameState.mapHeight;
            const map = Array.from({ length: h }, () => Array(w).fill(1));

            function carve(cx, cy) {
                const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]];
                directions.sort(() => Math.random() - 0.5);
                
                for (const [dx, dy] of directions) {
                    const nx = cx + dx;
                    const ny = cy + dy;

                    if (ny >= 0 && ny < h && nx >= 0 && nx < w && map[ny][nx] === 1) {
                        map[ny - dy / 2][nx - dx / 2] = 0;
                        map[ny][nx] = 0;
                        carve(nx, ny);
                    }
                }
            }

            map[1][1] = 0;
            carve(1, 1);
            
            // Open up some dead ends to make it less maze-like
            let openings = (w * h) / 10;
            while(openings > 0) {
                const x = Math.floor(Math.random() * (w - 2)) + 1;
                const y = Math.floor(Math.random() * (h - 2)) + 1;
                if(map[y][x] === 1) {
                    map[y][x] = 0;
                    openings--;
                }
            }
            
            gameState.map = map;
        }

        // --- Level Management ---
        async function generateLevel(level) {
            showLoadingScreen();
            await new Promise(resolve => setTimeout(resolve, 100)); // Allow UI to update

            gameState.currentLevel = level;
            gameState.sprites = [];
            gameState.player.hasKey = false;
            generateMap();

            const emptyTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (gameState.map[y][x] === 0) emptyTiles.push({x: x + 0.5, y: y + 0.5});
                }
            }

            const placeItem = (count, type, subType) => {
                for(let i=0; i<count; i++) {
                    if(emptyTiles.length === 0) return;
                    const tileIndex = Math.floor(Math.random() * emptyTiles.length);
                    const tile = emptyTiles.splice(tileIndex, 1)[0];
                    if (type === 'enemy') {
                         gameState.sprites.push({x: tile.x, y: tile.y, type: 'enemy', subType: subType, health: ENEMY_TYPES[subType].health, state: 'idle', isHit: 0, attackTimer: 0});
                    } else {
                         gameState.sprites.push({x: tile.x, y: tile.y, type: 'pickup', subType: subType});
                    }
                }
            };
            
            // Place player
            const playerTile = emptyTiles.splice(Math.floor(Math.random() * emptyTiles.length), 1)[0];
            gameState.player.x = playerTile.x;
            gameState.player.y = playerTile.y;
            
            // Difficulty scaling
            placeItem(2 + level, 'enemy', 'grunt');
            placeItem(1 + Math.floor(level / 2), 'enemy', 'sergeant');
            placeItem(Math.floor(level / 3), 'enemy', 'commander');
            placeItem(1, 'enemy', 'boss'); // Always one boss
            
            placeItem(Math.max(1, 5 - Math.floor(level/2)), 'pickup', 'ammo');
            placeItem(Math.max(1, 4 - Math.floor(level/2)), 'pickup', 'health');
            placeItem(Math.max(1, 3 - Math.floor(level/3)), 'pickup', 'shield');
            
            hideLoadingScreen();
        }

        function showLoadingScreen() {
            loadingScreen.style.top = '0';
        }
        function hideLoadingScreen() {
            loadingScreen.style.top = '-100%';
        }
        
        function spawnExitDoor() {
            const emptyTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (gameState.map[y][x] === 0 && Math.hypot(x - gameState.player.x, y - gameState.player.y) > 10) {
                         emptyTiles.push({x: x + 0.5, y: y + 0.5});
                    }
                }
            }
            if(emptyTiles.length > 0) {
                const tile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                gameState.sprites.push({x: tile.x, y: tile.y, type: 'exit'});
            }
        }

        // --- Game Logic ---
        function shoot() {
            const p = gameState.player;
            if (p.clipAmmo > 0) {
                p.clipAmmo--;
                let hitSprite = null;
                let closestDist = Infinity;
                for(let i = 0; i < gameState.sprites.length; i++) {
                     if (gameState.sprites[i].type === 'enemy' && gameState.sprites[i].state !== 'dead') {
                        const sprite = gameState.sprites[i];
                        const vecX = sprite.x - p.x;
                        const vecY = sprite.y - p.y;
                        const dist = vecX * vecX + vecY * vecY;
                        const angle = Math.atan2(vecY, vecX);
                        let playerAngle = Math.atan2(p.dirY, p.dirX);
                        let angleDiff = angle - playerAngle;
                        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                        if (Math.abs(angleDiff) < 0.1 && dist < closestDist) {
                            closestDist = dist;
                            hitSprite = sprite;
                        }
                    }
                }
                if (hitSprite) {
                    hitSprite.health -= 50;
                    hitSprite.isHit = 5;
                    if (hitSprite.health <= 0 && hitSprite.state !== 'dead') {
                        hitSprite.state = 'dead';
                        p.score += ENEMY_TYPES[hitSprite.subType].score;
                        if(hitSprite.subType === 'boss') {
                            gameState.sprites.push({x: hitSprite.x, y: hitSprite.y, type: 'pickup', subType: 'key'});
                            spawnExitDoor();
                        }
                    }
                }
            }
        }

        function reload() {
            const p = gameState.player;
            const ammoNeeded = CLIP_SIZE - p.clipAmmo;
            const ammoToMove = Math.min(ammoNeeded, p.ammo);
            p.clipAmmo += ammoToMove;
            p.ammo -= ammoToMove;
        }

        function playerTakeDamage(damage) {
            const p = gameState.player;
            p.isHit = 10;
            const shieldDamage = Math.min(p.shield, damage);
            p.shield -= shieldDamage;
            const healthDamage = damage - shieldDamage;
            p.health -= healthDamage;
            if (p.health <= 0) {
                p.health = 0;
                alert(`GAME OVER! Final Score: ${p.score} on Level ${gameState.currentLevel}`);
                document.location.reload();
            }
        }
        
        function isVisible(start, end) {
            let x0 = Math.floor(start.x), y0 = Math.floor(start.y);
            let x1 = Math.floor(end.x), y1 = Math.floor(end.y);
            let dx = Math.abs(x1 - x0), dy = -Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
            let err = dx + dy, e2;
            while (true) {
                if (gameState.map[y0][x0] === 1) return false;
                if (x0 === x1 && y0 === y1) break;
                e2 = 2 * err;
                if (e2 >= dy) { err += dy; x0 += sx; }
                if (e2 <= dx) { err += dx; y0 += sy; }
            }
            return true;
        }

        function updateState() {
            const p = gameState.player;
            const moveSpeed = p.moveSpeed;
            if (keys['KeyW'] || keys['ArrowUp']) {
                if (gameState.map[Math.floor(p.y)][Math.floor(p.x + p.dirX * moveSpeed)] == 0) p.x += p.dirX * moveSpeed;
                if (gameState.map[Math.floor(p.y + p.dirY * moveSpeed)][Math.floor(p.x)] == 0) p.y += p.dirY * moveSpeed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                if (gameState.map[Math.floor(p.y)][Math.floor(p.x - p.dirX * moveSpeed)] == 0) p.x -= p.dirX * moveSpeed;
                if (gameState.map[Math.floor(p.y - p.dirY * moveSpeed)][Math.floor(p.x)] == 0) p.y -= p.dirY * moveSpeed;
            }
            if (keys['KeyD']) {
                if (gameState.map[Math.floor(p.y)][Math.floor(p.x + p.planeX * moveSpeed)] == 0) p.x += p.planeX * moveSpeed;
                if (gameState.map[Math.floor(p.y + p.planeY * moveSpeed)][Math.floor(p.x)] == 0) p.y += p.planeY * moveSpeed;
            }
            if (keys['KeyA']) {
                if (gameState.map[Math.floor(p.y)][Math.floor(p.x - p.planeX * moveSpeed)] == 0) p.x -= p.planeX * moveSpeed;
                if (gameState.map[Math.floor(p.y - p.planeY * moveSpeed)][Math.floor(p.x)] == 0) p.y -= p.planeY * moveSpeed;
            }
            if (keys['KeyR']) reload();

            for (let i = gameState.sprites.length - 1; i >= 0; i--) {
                const sprite = gameState.sprites[i];
                const dist = Math.hypot(p.x - sprite.x, p.y - sprite.y);

                if (dist < 0.5) {
                    if (sprite.type === 'pickup') {
                        if (sprite.subType === 'ammo' && p.ammo < MAX_AMMO_CARRY) { p.ammo = Math.min(MAX_AMMO_CARRY, p.ammo + CLIP_SIZE); p.score += 10; gameState.sprites.splice(i, 1); }
                        if (sprite.subType === 'health' && p.health < MAX_HEALTH) { p.health = Math.min(MAX_HEALTH, p.health + 25); p.score += 10; gameState.sprites.splice(i, 1); }
                        if (sprite.subType === 'shield' && p.shield < MAX_SHIELD) { p.shield = Math.min(MAX_SHIELD, p.shield + 50); p.score += 10; gameState.sprites.splice(i, 1); }
                        if (sprite.subType === 'key') { p.hasKey = true; p.score += 500; gameState.sprites.splice(i, 1); }
                    } else if (sprite.type === 'exit' && p.hasKey) {
                        generateLevel(gameState.currentLevel + 1);
                        return; // Stop processing this frame
                    }
                }
                
                if (sprite.type === 'enemy') {
                    if (sprite.isHit > 0) sprite.isHit--;
                    if (sprite.state === 'dead') {
                        if (!sprite.deathTimer) sprite.deathTimer = 30;
                        sprite.deathTimer--;
                        if (sprite.deathTimer <= 0) gameState.sprites.splice(i, 1);
                        continue;
                    }
                    const canSeePlayer = isVisible(sprite, p);
                    if (canSeePlayer && dist < 10) sprite.state = 'attacking';
                    else if (canSeePlayer && dist < 20) sprite.state = 'chasing';
                    else sprite.state = 'idle';

                    if (sprite.state === 'chasing') {
                        const moveDirX = (p.x - sprite.x) / dist;
                        const moveDirY = (p.y - sprite.y) / dist;
                        const enemyMoveSpeed = 0.02;
                        if (gameState.map[Math.floor(sprite.y)][Math.floor(sprite.x + moveDirX * enemyMoveSpeed)] == 0) sprite.x += moveDirX * enemyMoveSpeed;
                        if (gameState.map[Math.floor(sprite.y + moveDirY * enemyMoveSpeed)][Math.floor(sprite.x)] == 0) sprite.y += moveDirY * enemyMoveSpeed;
                    } else if (sprite.state === 'attacking') {
                        sprite.attackTimer = (sprite.attackTimer || 0) + 1;
                        if (sprite.attackTimer >= ENEMY_TYPES[sprite.subType].attackCooldown) {
                            sprite.attackTimer = 0;
                            const bulletDirX = (p.x - sprite.x) / dist;
                            const bulletDirY = (p.y - sprite.y) / dist;
                            gameState.sprites.push({ type: 'projectile', x: sprite.x, y: sprite.y, dirX: bulletDirX, dirY: bulletDirY, speed: 0.1, damage: ENEMY_TYPES[sprite.subType].damage, color: '#FFA500' });
                        }
                    }
                } else if (sprite.type === 'projectile') {
                    sprite.x += sprite.dirX * sprite.speed;
                    sprite.y += sprite.dirY * sprite.speed;
                    if (gameState.map[Math.floor(sprite.y)][Math.floor(sprite.x)] !== 0) {
                        gameState.sprites.splice(i, 1);
                    } else if (Math.hypot(p.x - sprite.x, p.y - sprite.y) < 0.5) {
                        playerTakeDamage(sprite.damage);
                        gameState.sprites.splice(i, 1);
                    }
                }
            }
            if (p.isHit > 0) p.isHit--;
        }

        // --- Rendering ---
        function render() {
            const p = gameState.player;
            ctx.clearRect(0, 0, screenWidth, screenHeight);
            ctx.fillStyle = '#3c3c3c';
            ctx.fillRect(0, 0, screenWidth, screenHeight / 2);
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(0, screenHeight / 2, screenWidth, screenHeight);

            for (let x = 0; x < screenWidth; x++) {
                const cameraX = 2 * x / screenWidth - 1;
                const rayDirX = p.dirX + p.planeX * cameraX;
                const rayDirY = p.dirY + p.planeY * cameraX;
                let mapX = Math.floor(p.x);
                let mapY = Math.floor(p.y);
                const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1 / rayDirX);
                const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1 / rayDirY);
                let stepX, stepY, sideDistX, sideDistY;
                let hit = 0, side;

                if (rayDirX < 0) { stepX = -1; sideDistX = (p.x - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - p.x) * deltaDistX; }
                if (rayDirY < 0) { stepY = -1; sideDistY = (p.y - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - p.y) * deltaDistY; }

                while (hit === 0) {
                    if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                    if (gameState.map[mapY][mapX] > 0) hit = 1;
                }

                const perpWallDist = (side === 0) ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
                gameState.zBuffer[x] = perpWallDist;

                const lineHeight = Math.floor(screenHeight / perpWallDist);
                const drawStart = Math.max(0, -lineHeight / 2 + screenHeight / 2);
                const drawEnd = Math.min(screenHeight - 1, lineHeight / 2 + screenHeight / 2);

                let color = '#800000';
                if (side === 1) { color = '#b30000'; }

                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.moveTo(x, drawStart);
                ctx.lineTo(x, drawEnd);
                ctx.stroke();
            }

            gameState.sprites.sort((a, b) => Math.hypot(b.x - p.x, b.y - p.y) - Math.hypot(a.x - p.x, a.y - p.y));

            for (let i = 0; i < gameState.sprites.length; i++) {
                const sprite = gameState.sprites[i];
                const spriteX = sprite.x - p.x;
                const spriteY = sprite.y - p.y;
                const invDet = 1.0 / (p.planeX * p.dirY - p.dirX * p.planeY);
                const transformX = invDet * (p.dirY * spriteX - p.dirX * spriteY);
                const transformY = invDet * (-p.planeY * spriteX + p.planeX * spriteY);

                if (transformY > 0) {
                    const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));
                    let spriteScale = 1.0, spriteAspectRatio = 1.0, spriteColor;
                    
                    if (sprite.type === 'enemy') {
                        spriteScale = ENEMY_TYPES[sprite.subType].scale;
                        spriteAspectRatio = ENEMY_TYPES[sprite.subType].aspectRatio;
                        spriteColor = sprite.isHit > 0 ? '#ffcccc' : ENEMY_TYPES[sprite.subType].color;
                        if (sprite.state === 'dead') spriteColor = '#404040';
                    } else if (sprite.type === 'pickup') {
                        spriteScale = 0.25;
                        if (sprite.subType === 'ammo') spriteColor = '#ffff00';
                        else if (sprite.subType === 'health') spriteColor = '#ff0000';
                        else if (sprite.subType === 'shield') spriteColor = '#0000ff';
                        else if (sprite.subType === 'key') { spriteColor = '#f0e68c'; spriteScale = 0.4; }
                    } else if (sprite.type === 'exit') {
                        spriteColor = '#ffffff'; spriteScale = 1.2; spriteAspectRatio = 0.5;
                    } else if (sprite.type === 'projectile') {
                        spriteScale = 0.15;
                        spriteColor = sprite.color;
                    }

                    const spriteHeight = Math.abs(Math.floor(screenHeight / transformY)) * spriteScale;
                    const spriteWidth = spriteHeight * spriteAspectRatio;
                    const drawStartY = -spriteHeight / 2 + screenHeight / 2;
                    const drawEndX = spriteWidth / 2 + spriteScreenX;

                    for (let stripe = Math.floor(drawEndX - spriteWidth); stripe < Math.floor(drawEndX); stripe++) {
                        if (stripe >= 0 && stripe < screenWidth && transformY < gameState.zBuffer[stripe]) {
                            ctx.fillStyle = spriteColor;
                            ctx.fillRect(stripe, drawStartY, 1, spriteHeight);
                            if (sprite.type === 'enemy' && sprite.state !== 'dead') {
                                const healthBarWidth = spriteWidth * (sprite.health / ENEMY_TYPES[sprite.subType].health);
                                ctx.fillStyle = 'red';
                                ctx.fillRect(drawEndX - spriteWidth, drawStartY - 10, spriteWidth, 5);
                                ctx.fillStyle = 'green';
                                ctx.fillRect(drawEndX - spriteWidth, drawStartY - 10, healthBarWidth, 5);
                            }
                        }
                    }
                }
            }
            
            if (p.isHit > 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(0, 0, screenWidth, screenHeight);
            }

            // --- Minimap Rendering ---
            const miniMapSize = 120;
            const miniMapX = screenWidth - miniMapSize - 10;
            const miniMapY = 10;
            const tileSize = miniMapSize / gameState.mapWidth;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(miniMapX, miniMapY, miniMapSize, miniMapSize);

            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (gameState.map[y][x] === 1) {
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
                        ctx.fillRect(miniMapX + x * tileSize, miniMapY + y * tileSize, tileSize, tileSize);
                    }
                }
            }
            
            for (let i = 0; i < gameState.sprites.length; i++) {
                const sprite = gameState.sprites[i];
                let color = null;
                if (sprite.type === 'enemy' && sprite.state !== 'dead') color = 'red';
                else if (sprite.type === 'pickup' && sprite.subType === 'key') color = '#f0e68c';
                else if (sprite.type === 'exit') color = 'white';
                
                if (color) {
                    ctx.fillStyle = color;
                    ctx.fillRect(miniMapX + sprite.x * tileSize - 1, miniMapY + sprite.y * tileSize - 1, 3, 3);
                }
            }

            const playerMiniMapX = miniMapX + p.x * tileSize;
            const playerMiniMapY = miniMapY + p.y * tileSize;
            ctx.fillStyle = 'yellow';
            ctx.fillRect(playerMiniMapX - 2, playerMiniMapY - 2, 4, 4);

            // Draw player direction indicator
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(playerMiniMapX, playerMiniMapY);
            ctx.lineTo(
                playerMiniMapX + p.dirX * 5,
                playerMiniMapY + p.dirY * 5
            );
            ctx.stroke();
            
            // --- UI Text ---
            document.getElementById('level-ui').innerText = `Level: ${gameState.currentLevel}`;
            document.getElementById('health-ui').innerText = `Health: ${p.health}`;
            document.getElementById('shield-ui').innerText = `Shield: ${p.shield}`;
            document.getElementById('ammo-ui').innerText = `Ammo: ${p.clipAmmo} / ${p.ammo}`;
            document.getElementById('score-ui').innerText = `Score: ${p.score}`;
        }

        function gameLoop() {
            updateState();
            render();
            requestAnimationFrame(gameLoop);
        }

        generateLevel(1).then(gameLoop);
    </script>
</body>
</html>
